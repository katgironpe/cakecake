b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge
b2Mat22 = Box2D.Common.Math.b2Mat22
b2Mat33 = Box2D.Common.Math.b2Mat33
b2Math = Box2D.Common.Math.b2Math
b2Sweep = Box2D.Common.Math.b2Sweep
b2Transform = Box2D.Common.Math.b2Transform
b2Vec2 = Box2D.Common.Math.b2Vec2
b2Vec3 = Box2D.Common.Math.b2Vec3
b2Color = Box2D.Common.b2Color
b2internal = Box2D.Common.b2internal
b2Settings = Box2D.Common.b2Settings
b2AABB = Box2D.Collision.b2AABB
b2Bound = Box2D.Collision.b2Bound
b2BoundValues = Box2D.Collision.b2BoundValues
b2Collision = Box2D.Collision.b2Collision
b2ContactID = Box2D.Collision.b2ContactID
b2ContactPoint = Box2D.Collision.b2ContactPoint
b2Distance = Box2D.Collision.b2Distance
b2DistanceInput = Box2D.Collision.b2DistanceInput
b2DistanceOutput = Box2D.Collision.b2DistanceOutput
b2DistanceProxy = Box2D.Collision.b2DistanceProxy
b2DynamicTree = Box2D.Collision.b2DynamicTree
b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase
b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode
b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair
b2Manifold = Box2D.Collision.b2Manifold
b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint
b2Point = Box2D.Collision.b2Point
b2RayCastInput = Box2D.Collision.b2RayCastInput
b2RayCastOutput = Box2D.Collision.b2RayCastOutput
b2Segment = Box2D.Collision.b2Segment
b2SeparationFunction = Box2D.Collision.b2SeparationFunction
b2Simplex = Box2D.Collision.b2Simplex
b2SimplexCache = Box2D.Collision.b2SimplexCache
b2SimplexVertex = Box2D.Collision.b2SimplexVertex
b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact
b2TOIInput = Box2D.Collision.b2TOIInput
b2WorldManifold = Box2D.Collision.b2WorldManifold
ClipVertex = Box2D.Collision.ClipVertex
Features = Box2D.Collision.Features
IBroadPhase = Box2D.Collision.IBroadPhase
b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef
b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape
b2MassData = Box2D.Collision.Shapes.b2MassData
b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
b2Shape = Box2D.Collision.Shapes.b2Shape
b2Body = Box2D.Dynamics.b2Body
b2BodyDef = Box2D.Dynamics.b2BodyDef
b2ContactFilter = Box2D.Dynamics.b2ContactFilter
b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse
b2ContactListener = Box2D.Dynamics.b2ContactListener
b2ContactManager = Box2D.Dynamics.b2ContactManager
b2DebugDraw = Box2D.Dynamics.b2DebugDraw
b2DestructionListener = Box2D.Dynamics.b2DestructionListener
b2FilterData = Box2D.Dynamics.b2FilterData
b2Fixture = Box2D.Dynamics.b2Fixture
b2FixtureDef = Box2D.Dynamics.b2FixtureDef
b2Island = Box2D.Dynamics.b2Island
b2TimeStep = Box2D.Dynamics.b2TimeStep
b2World = Box2D.Dynamics.b2World
b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact
b2Contact = Box2D.Dynamics.Contacts.b2Contact
b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint
b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint
b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge
b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory
b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister
b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult
b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver
b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact
b2NullContact = Box2D.Dynamics.Contacts.b2NullContact
b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact
b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact
b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact
b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold
b2Controller = Box2D.Dynamics.Controllers.b2Controller
b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint
b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef
b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint
b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef
b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint
b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef
b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian
b2Joint = Box2D.Dynamics.Joints.b2Joint
b2JointDef = Box2D.Dynamics.Joints.b2JointDef
b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge
b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint
b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef
b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint
b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint
b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef
b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint
b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef
b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint
b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef
b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint
b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef

console.log Box2D

#Vector from this to that
Box2D.Common.Math.b2Vec2::to = (that) ->
  vec = that.Copy()
  vec.Subtract(this)
  return vec

#Multiply with number
Box2D.Common.Math.b2Vec2::multiply = (scale) ->
  @x = @x*scale
  @y = @y*scale

#Divide with number
Box2D.Common.Math.b2Vec2::divide = (scale) ->
  @x = @x/scale
  @y = @y/scale

#Closer to
Box2D.Common.Math.b2Vec2::closer_to = (that,n) ->
  t1 = this.to(that)
  t1.Normalize()
  t1.Multiply(n)
  t1.Add(this)
  return t1
  

Box2D.Common.Math.b2Vec2::dot = (vec) ->
  console.log "calculate dot product"

Box2D.Common.Math.b2Vec2::proj = (vec) ->
  console.log "calculate projection vector"

Box2D.Common.Math.b2Vec2::cross = (vec) ->
  console.log "calculate cross project"

Box2D.Common.Math.b2Vec2::angle = ->
  return Math.atan2(@y,@x)

Box2D.Common.Math.b2Vec2::angle_between = (vec) ->
  console.log "calculate angle between"
  return self.dot(vec) / (vec.Length * self.Length)

class Physics
  world: null
  fix_def: null
  solid: null
  PTM: 16

  # body definition: Defines a body
  # body: moving objects
  # fixture: part of body
  # shape: trigometric shape

  constructor: ->
    @fix_def = new b2FixtureDef
    @fix_def.density = 1.0
    @fix_def.friction = 0.5
    @fix_def.restitution = 0.2

    @create_world()
    @setup_debug_draw()
    solid_def = new b2BodyDef()
    solid_def.position.Set(0,0)
    @solid = @world.CreateBody(solid_def)
    @build_edges()
    @build_boxes()

  create_world: ->
    @world = new b2World(new b2Vec2(0.0, 60.0),true)

  setup_debug_draw: ->
    debugDraw = new b2DebugDraw()
    debugDraw.SetSprite(Game.context)
    debugDraw.SetDrawScale(@PTM)
    debugDraw.SetFillAlpha(0.5)
    debugDraw.SetLineThickness(1.0)
    debugDraw.SetFlags(b2DebugDraw.e_shapeBit )
    @world.SetDebugDraw(debugDraw)

  build_edges: ->
    @build_solid_line(0,0,AppData.width,0)
    @build_solid_line(0,AppData.height,AppData.width,AppData.height)
    @build_solid_line(0,0,0,AppData.height)
    @build_solid_line(AppData.width,0,AppData.width,AppData.height)

  build_boxes: ->
    @build_solid_box(32,32,32,32,45)
    @build_solid_box(64,128,16,64,0)
    @build_solid_box(232,62,132,8,10)
    @build_solid_circle(200,90,22)

  build_solid_line: (x1,y1,x2,y2) ->
    @fix_def.shape = new b2PolygonShape
    @fix_def.shape.SetAsEdge(new b2Vec2(x1/@PTM, y1/@PTM), new b2Vec2(x2/@PTM, y2/@PTM))
    @solid.CreateFixture(@fix_def);

  build_solid_box: (x,y,w,h,rotation) ->
    @fix_def.shape = new b2PolygonShape
    @fix_def.shape.SetAsOrientedBox w/(@PTM)/2, h/(@PTM)/2, new b2Vec2(x/@PTM,y/@PTM), -rotation/180*Math.PI
    @solid.CreateFixture(@fix_def);

  build_solid_circle: (x,y,r) ->
    @fix_def.shape = new b2CircleShape
    @fix_def.shape.SetRadius r/@PTM
    console.log @fix_def.shape
    @fix_def.shape.m_p = new b2Vec2(x/@PTM,y/@PTM)
    @solid.CreateFixture(@fix_def);

  build_dynamic: (x,y,w,h,physics) ->
    bd = new b2BodyDef()
    bd.type = b2Body.b2_dynamicBody
    bd.position.Set(x/@PTM, y/@PTM)
    if physics.shape == 'circle'
      shape = new b2CircleShape()
      shape.SetRadius Math.max(w,h)/@PTM/2
    else
      shape = new b2PolygonShape()
      shape.SetAsBox w/@PTM/2, h/@PTM/2
    fd = new b2FixtureDef()
    fd.shape = shape
    fd.density = physics.density
    fd.friction = physics.friction
    fd.restitution = physics.restitution
    body = @world.CreateBody(bd)
    body.CreateFixture fd
    return body

  draw: (x,y) ->
    Game.context.save()
    Game.context.translate(x,y)
    @world.DrawDebugData()
    Game.context.restore()
