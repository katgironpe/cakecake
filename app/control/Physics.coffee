
b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge
b2Mat22 = Box2D.Common.Math.b2Mat22
b2Mat33 = Box2D.Common.Math.b2Mat33
b2Math = Box2D.Common.Math.b2Math
b2Sweep = Box2D.Common.Math.b2Sweep
b2Transform = Box2D.Common.Math.b2Transform
b2Vec2 = Box2D.Common.Math.b2Vec2
b2Vec3 = Box2D.Common.Math.b2Vec3
b2Color = Box2D.Common.b2Color
b2internal = Box2D.Common.b2internal
b2Settings = Box2D.Common.b2Settings
b2AABB = Box2D.Collision.b2AABB
b2Bound = Box2D.Collision.b2Bound
b2BoundValues = Box2D.Collision.b2BoundValues
b2Collision = Box2D.Collision.b2Collision
b2ContactID = Box2D.Collision.b2ContactID
b2ContactPoint = Box2D.Collision.b2ContactPoint
b2Distance = Box2D.Collision.b2Distance
b2DistanceInput = Box2D.Collision.b2DistanceInput
b2DistanceOutput = Box2D.Collision.b2DistanceOutput
b2DistanceProxy = Box2D.Collision.b2DistanceProxy
b2DynamicTree = Box2D.Collision.b2DynamicTree
b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase
b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode
b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair
b2Manifold = Box2D.Collision.b2Manifold
b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint
b2Point = Box2D.Collision.b2Point
b2RayCastInput = Box2D.Collision.b2RayCastInput
b2RayCastOutput = Box2D.Collision.b2RayCastOutput
b2Segment = Box2D.Collision.b2Segment
b2SeparationFunction = Box2D.Collision.b2SeparationFunction
b2Simplex = Box2D.Collision.b2Simplex
b2SimplexCache = Box2D.Collision.b2SimplexCache
b2SimplexVertex = Box2D.Collision.b2SimplexVertex
b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact
b2TOIInput = Box2D.Collision.b2TOIInput
b2WorldManifold = Box2D.Collision.b2WorldManifold
ClipVertex = Box2D.Collision.ClipVertex
Features = Box2D.Collision.Features
IBroadPhase = Box2D.Collision.IBroadPhase
b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef
b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape
b2MassData = Box2D.Collision.Shapes.b2MassData
b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
b2Shape = Box2D.Collision.Shapes.b2Shape
b2Body = Box2D.Dynamics.b2Body
b2BodyDef = Box2D.Dynamics.b2BodyDef
b2ContactFilter = Box2D.Dynamics.b2ContactFilter
b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse
b2ContactListener = Box2D.Dynamics.b2ContactListener
b2ContactManager = Box2D.Dynamics.b2ContactManager
b2DebugDraw = Box2D.Dynamics.b2DebugDraw
b2DestructionListener = Box2D.Dynamics.b2DestructionListener
b2FilterData = Box2D.Dynamics.b2FilterData
b2Fixture = Box2D.Dynamics.b2Fixture
b2FixtureDef = Box2D.Dynamics.b2FixtureDef
b2Island = Box2D.Dynamics.b2Island
b2TimeStep = Box2D.Dynamics.b2TimeStep
b2World = Box2D.Dynamics.b2World
b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact
b2Contact = Box2D.Dynamics.Contacts.b2Contact
b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint
b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint
b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge
b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory
b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister
b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult
b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver
b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact
b2NullContact = Box2D.Dynamics.Contacts.b2NullContact
b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact
b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact
b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact
b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold
b2Controller = Box2D.Dynamics.Controllers.b2Controller
b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint
b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef
b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint
b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef
b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint
b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef
b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian
b2Joint = Box2D.Dynamics.Joints.b2Joint
b2JointDef = Box2D.Dynamics.Joints.b2JointDef
b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge
b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint
b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef
b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint
b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint
b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef
b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint
b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef
b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint
b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef
b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint
b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef

#As documentation
console.log Box2D

#Vector from this to that
Box2D.Common.Math.b2Vec2::to = (that) ->
  vec = that.Copy()
  vec.Subtract(this)
  return vec

#Multiply with number
Box2D.Common.Math.b2Vec2::multiply = (scale) ->
  @x = @x*scale
  @y = @y*scale

#Divide with number
Box2D.Common.Math.b2Vec2::divide = (scale) ->
  @x = @x/scale
  @y = @y/scale

#Closer to
Box2D.Common.Math.b2Vec2::closer_to = (that,n) ->
  t1 = this.to(that)
  t1.Normalize()
  t1.Multiply(n)
  t1.Add(this)
  return t1

#Angle (in radians)
Box2D.Common.Math.b2Vec2::angle = ->
  return Math.atan2(@y,@x)

#Untested:
Box2D.Common.Math.b2Vec2::angle_between = (vec) ->
  return self.dot(vec) / (vec.Length * self.Length)

Box2D.Common.Math.b2Vec2::dot = (vec) ->
  console.log "calculate dot product"

Box2D.Common.Math.b2Vec2::proj = (vec) ->
  console.log "calculate projection vector"

Box2D.Common.Math.b2Vec2::cross = (vec) ->
  console.log "calculate cross project"

class Physics
  world: null
  fix_def: null
  solid: null
  visible: false

  constructor: ->
    @fix_def = new b2FixtureDef
    @fix_def.density = 1.0
    @fix_def.friction = 0.5
    @fix_def.restitution = 0.2

    @create_world()
    @setup_debug_draw()

    solid_def = new b2BodyDef()
    solid_def.position.Set(0,0)
    @solid = @world.CreateBody(solid_def)
    @solid.SetUserData('my_SOLID')

    @setup_contact_listener()

  setup_contact_listener: ->
    contact_listener = new b2ContactListener
    contact_listener.BeginContact = (contact) =>
      a = contact.GetFixtureA().GetBody().GetUserData()
      b = contact.GetFixtureB().GetBody().GetUserData()
      if a instanceof Entity and b instanceof Entity
        a.hit_hash[b] = a
        b.hit_hash[a] = b
    contact_listener.EndContact = (contact) =>
      a = contact.GetFixtureA().GetBody().GetUserData()
      b = contact.GetFixtureB().GetBody().GetUserData()
      if a instanceof Entity and b instanceof Entity
        delete a.hit_hash[b]
        delete b.hit_hash[a]
    @world.SetContactListener(contact_listener)

  create_world: ->
    @world = new b2World(new b2Vec2(0.0, 60.0),true)

  setup_debug_draw: ->
    debugDraw = new b2DebugDraw()
    debugDraw.SetSprite(Game.context)
    debugDraw.SetDrawScale(AppData.pixel_per_meter)
    debugDraw.SetFillAlpha(0.5)
    debugDraw.SetLineThickness(1.0)
    debugDraw.SetFlags(b2DebugDraw.e_shapeBit )
    @world.SetDebugDraw(debugDraw)

  build_edges: ->
    @build_solid_line(0,0,AppData.width,0)
    @build_solid_line(0,AppData.height,AppData.width,AppData.height)
    @build_solid_line(0,0,0,AppData.height)
    @build_solid_line(AppData.width,0,AppData.width,AppData.height)

  build_solid_line: (x1,y1,x2,y2) ->
    @fix_def.shape = new b2PolygonShape
    @fix_def.shape.SetAsEdge(new b2Vec2(x1/AppData.pixel_per_meter, y1/AppData.pixel_per_meter), new b2Vec2(x2/AppData.pixel_per_meter, y2/AppData.pixel_per_meter))
    @solid.CreateFixture(@fix_def)

  build_solid_box: (x,y,width,height,angle) ->
    @fix_def.shape = new b2PolygonShape
    @fix_def.shape.SetAsOrientedBox width/(AppData.pixel_per_meter)/2, height/(AppData.pixel_per_meter)/2, new b2Vec2(x/AppData.pixel_per_meter,y/AppData.pixel_per_meter), -angle/180*Math.PI
    @solid.CreateFixture(@fix_def)

  build_solid_circle: (x,y,radius) ->
    @fix_def.shape = new b2CircleShape
    @fix_def.shape.SetRadius radius/AppData.pixel_per_meter
    console.log @fix_def.shape
    @fix_def.shape.m_p = new b2Vec2(x/AppData.pixel_per_meter,y/AppData.pixel_per_meter)
    @solid.CreateFixture(@fix_def)

  build_dynamic: (x,y,width,height,radius,physics) ->
    if physics.shape == 'circle'
      shape = new b2CircleShape()
      shape.SetRadius radius/AppData.pixel_per_meter
    else
      shape = new b2PolygonShape()
      shape.SetAsBox width/AppData.pixel_per_meter/2, height/AppData.pixel_per_meter/2

    fd = new b2FixtureDef()
    fd.shape = shape
    fd.density = physics.density
    fd.friction = physics.friction
    fd.restitution = physics.restitution
    bd = new b2BodyDef()
    bd.position.Set(x/AppData.pixel_per_meter, y/AppData.pixel_per_meter)

    if physics.type == 'dynamic'
      bd.type = b2Body.b2_dynamicBody
    else
      bd.type = b2Body.b2_staticBody
      fd.isSensor = true

    if physics.solid == true
      fd.isSensor = false

    body = @world.CreateBody(bd)
    body.CreateFixture fd
    return body

  draw: (x,y) ->
    if @visible
      Game.context.save()
      Game.context.translate(x,y)
      @world.DrawDebugData()
      Game.context.restore()
